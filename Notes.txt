12/27/2020
    Problem parsing Terms with no explicit coefficient. Ex: x^(23)
        x^(2) is not parsed as a single token [Fixed by starting i at 0, not 1]
    -2+8 is converted to +`2+8 [Fixed by adding check for i == 0 in formatInputExpression() (Expression.cpp)]
    (-2+8) * (6-(-1)) SIGABRTs [Fixed by adding check for i > 0 when parsing string b in formatInputExpression() (Expression.cpp)]
    (-2+8) Segfaults b/c it is formatted as (+`2+8) [Fixed by adding a check that charAt(i - 1) is not a '(' in formatInputExpression() (Expression.cpp)]

    End of day. Next steps are to run test cases and implement pow().

12/28/2020
    12:27 -- Taking a break. Pick up working on Expression::addLikeTerms()
    17:31 -- Need to figure out how to make all operators after Expression::evaluate() to be '+' so that Expression::addLikeTerms() works correctly

12/31/2020
    Expression::formatInputExpression() -- Automatically add '-' symbols to processed, then check end of processed to determine what to do with
                                            additional '-' symbols (i.e. replace two with '+', replace one with '`')
    Term::parseTerm() -- Fixed some bugs with parsing coefficients and variables

    Future problem that will arise:
        std::to_string() gives only 6 digits of precision, so anything less than 0.000001 will be printed as 0
        Most likely need to create my own version of std::to_string() that gives a variable amount of precision
        But how?

    To work on next: Arithmetic::pow()
                     Run test cases (set up unit tests?)

01/01/2021
    Got prototype of Arithmetic::pow() done

01/02/2021
    Fixed pretty major issue with Expression::infixToPostfix(). Had a > instead of >=, making the
    postfixed expression completely incorrect (in most cases)

    Something to note:
        The expression -3^2 would evaluate to -9 following conventional rules; however,
        this library parses the -3 as a whole term and not the negation of the expression 3^2.
        This may cause problems down the road, but I am going to leave it be for now since it
        can easily be avoided by clarifying the intended expression with a set of parentheses.

        Additionally, 2^3^-2 would conventionally be parsed as 2^(3^-2), but this library parses
        it as (2^3)^-2. As with above, I think this is more or less a trivial problem and can easily
        be remedied with a clarifying pair of parentheses. I will most likely add the rule to make
        automatic inferences in these situations, but it's not a pressing issue.

    Another thought I had was that of floating-point arithmetic error. I don't know of any built-in
    ways to minimize it, but I think it's definitely worth researching, especially as I look to
    close out this project soon.

01/03/2021
    Did some testing and fixed some small bugs. It looks like everything is working pretty much as
    intended.
    Thinking about replacing the expression parsing with a tree-based approach, as opposed to my current
    list-based approach. I think it could be written cleaner than what I have now, and it seems like
    it is more logical and understandable. Also, it should be just as efficient, if not more.