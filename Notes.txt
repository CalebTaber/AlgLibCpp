12/27/2020
    Problem parsing Terms with no explicit coefficient. Ex: x^(23)
        x^(2) is not parsed as a single token [Fixed by starting i at 0, not 1]
    -2+8 is converted to +`2+8 [Fixed by adding check for i == 0 in formatInputExpression() (Expression.cpp)]
    (-2+8) * (6-(-1)) SIGABRTs [Fixed by adding check for i > 0 when parsing string b in formatInputExpression() (Expression.cpp)]
    (-2+8) Segfaults b/c it is formatted as (+`2+8) [Fixed by adding a check that charAt(i - 1) is not a '(' in formatInputExpression() (Expression.cpp)]

    End of day. Next steps are to run test cases and implement pow().

12/28/2020
    12:27 -- Taking a break. Pick up working on Expression::addLikeTerms()
    17:31 -- Need to figure out how to make all operators after Expression::evaluate() to be '+' so that Expression::addLikeTerms() works correctly

12/31/2020
    Expression::formatInputExpression() -- Automatically add '-' symbols to processed, then check end of processed to determine what to do with
                                            additional '-' symbols (i.e. replace two with '+', replace one with '`')
    Term::parseTerm() -- Fixed some bugs with parsing coefficients and variables

    Future problem that will arise:
        std::to_string() gives only 6 digits of precision, so anything less than 0.000001 will be printed as 0
        Most likely need to create my own version of std::to_string() that gives a variable amount of precision
        But how?

    To work on next: Arithmetic::pow()
                     Run test cases (set up unit tests?)

01/01/2021
    Got prototype of Arithmetic::pow() done
